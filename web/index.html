<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pion WebRTC App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
        }

        #join-screen {
            margin-top: 100px;
        }

        #participant-view {
            margin-top: 20px;
        }

        #videos {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        #controls {
            margin-top: 20px;
        }

    </style>
</head>
<body>
    <div id="join-screen">
        <input type="text" id="name" placeholder="Enter your name">
        <button id="join-btn">Join</button>
    </div>
    <div id="participant-view" style="display: none;">
        <div id="videos"></div>
        <div id="controls">
            <button id="mute-btn">Mute</button>
            <button id="video-btn">Stop Video</button>
        </div>
    </div>
    <script>
        document.getElementById('join-btn').addEventListener('click', joinSession);
        document.getElementById('mute-btn').addEventListener('click', toggleMute);
        document.getElementById('video-btn').addEventListener('click', toggleVideo);

        let localStream;
        let peers = {};
        let ws;

        let peerConnection;
        let isMuted = false;
        let isVideoStopped = false;

        let myName;

        async function joinSession() {
            myName = document.getElementById('name').value;
            if (!myName) {
                alert('Please enter your name');
                return;
            }

            document.getElementById('join-screen').style.display = 'none';
            document.getElementById('participant-view').style.display = 'block';

            ws = new WebSocket(`wss://noremac.dev/ws`);

            ws.onopen = () => {
                console.log('âœ… WebSocket connection opened');
                ws.send(JSON.stringify({ type: 'join', name: myName }));
            };
            
            ws.onerror = (error) => {
                console.error('âŒ WebSocket Error:', error);
            };
            
            ws.onclose = () => {
                console.warn('âš ï¸ WebSocket connection closed');
            };
            
     
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

            const localVideo = document.createElement('video');
            localVideo.srcObject = localStream;
            localVideo.autoplay = true;
            localVideo.muted = true;
            document.getElementById('videos').appendChild(localVideo);

            ws.onmessage = async (message) => {
                const data = JSON.parse(message.data);
                console.log('ðŸ“© WebSocket received:', data);

                switch (data.type) {
                    case 'join':
                        if (data.name !== myName) {
                            console.log(`ðŸ“¡ Creating offer for ${data.name}`);
                            await createOffer(data.name);
                        }
                        break;
                    case 'offer':
                        console.log(`ðŸ“¡ Received offer from ${data.name}`);
                        await createAnswer(data.name, data.offer);
                        break;
                    case 'answer':
                        console.log(`ðŸ“¡ Received answer from ${data.name}`);
                        if (peers[data.name]) {
                            await peers[data.name].setRemoteDescription(new RTCSessionDescription(data.answer));
                            console.log(`âœ… Remote description set for ${data.name}`);

                            // Apply any queued ICE candidates
                            if (peers[data.name].queuedCandidates && peers[data.name].queuedCandidates.length > 0) {
                                console.log(`ðŸš€ Applying ${peers[data.name].queuedCandidates.length} queued ICE candidates for ${data.name}`);
                                for (const candidate of peers[data.name].queuedCandidates) {
                                    await peers[data.name].addIceCandidate(new RTCIceCandidate(candidate));
                                }
                                peers[data.name].queuedCandidates = []; // Clear queue
                            }
                        } else {
                            console.warn(`âš ï¸ No peer connection found for ${data.name} when setting remote description!`);
                        }
                        break;
                    case 'candidate':
                        if (peers[data.name] && peers[data.name].remoteDescription) {
                            console.log(`ðŸ“¡ Adding ICE candidate for ${data.name}`);
                            await peers[data.name].addIceCandidate(new RTCIceCandidate(data.candidate));
                        } else {
                            if (!peers[data.name]) {
                                peers[data.name] = { queuedCandidates: [] };
                            }
                            if (!peers[data.name].queuedCandidates) {
                                peers[data.name].queuedCandidates = [];
                            }
                            console.warn(`âš ï¸ Queuing ICE candidate for ${data.name} (remote description not set yet)`);
                            peers[data.name].queuedCandidates.push(data.candidate);
                        }
                        break;
                    case 'leave':
                        handleUserDisconnect(data.name);
                        break;
                }
            };
        }

        async function createOffer(name) {
            console.log(`ðŸ“¡ Sending WebRTC Offer to ${name}`);

            const peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            peers[name] = peerConnection; // âœ… Store the connection before doing anything

            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`ðŸ“¡ Sending ICE candidate for ${name}`);
                    ws.send(JSON.stringify({ type: 'candidate', name, candidate: event.candidate }));
                }
            };

            peerConnection.ontrack = (event) => {
                console.log(`ðŸ“º Video stream received from ${name}`);
                addRemoteStream(event.streams[0], name);
            };

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            console.log(`âœ… Offer created and local description set for ${name}`);

            ws.send(JSON.stringify({ type: 'offer', name, offer }));
        }

        async function createAnswer(name, offer) {
            console.log(`ðŸ“¡ Answering WebRTC Offer from ${name}`);

            // âœ… Create a new PeerConnection
            const peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            // âœ… Store the peer connection first
            peers[name] = peerConnection;

            // âœ… Add local media tracks (video & audio)
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // âœ… Handle new ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`ðŸ“¡ Sending ICE candidate for ${name}`);
                    ws.send(JSON.stringify({ type: 'candidate', name, candidate: event.candidate }));
                }
            };

            // âœ… Handle incoming media streams
            peerConnection.ontrack = (event) => {
                console.log(`ðŸ“º Video stream received from ${name}`);
                addRemoteStream(event.streams[0], name);
            };

            // âœ… Handle connection state changes (Detect failures)
            peerConnection.oniceconnectionstatechange = () => {
                if (peerConnection.iceConnectionState === 'failed') {
                    console.warn(`âš ï¸ ICE connection failed for ${name}, attempting restart`);
                    peerConnection.restartIce(); // Restart ICE if failure detected
                }
            };

            // âœ… Set the remote description (received offer)
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                console.log(`âœ… Remote offer set for ${name}`);
            } catch (error) {
                console.error(`âŒ Error setting remote description: ${error}`);
                return;
            }

            // âœ… Check and apply queued ICE candidates
            if (peers[name].queuedCandidates && peers[name].queuedCandidates.length > 0) {
                console.log(`ðŸš€ Applying queued ICE candidates for ${name}`);
                for (const candidate of peers[name].queuedCandidates) {
                    await peers[name].addIceCandidate(new RTCIceCandidate(candidate));
                }
                peers[name].queuedCandidates = []; // Clear queue after applying
            }

            // âœ… Create an answer and set local description
            try {
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log(`âœ… Answer created and local description set for ${name}`);

                // âœ… Send the answer back to the offerer
                ws.send(JSON.stringify({ type: 'answer', name, answer }));
            } catch (error) {
                console.error(`âŒ Error creating or setting answer: ${error}`);
            }
        }

        function addRemoteStream(stream, name) {
            if (document.getElementById(`video-${name}`)) {
                if (!peers[name].loggedDuplicate) {
                    console.warn(`âš ï¸ Duplicate video for ${name}. Skipping.`);
                    peers[name].loggedDuplicate = true; // Log only once
                }
                return;
            }

            let remoteVideo = document.createElement('video');
            remoteVideo.srcObject = stream;
            remoteVideo.autoplay = true;
            remoteVideo.id = `video-${name}`;
            document.getElementById('videos').appendChild(remoteVideo);

            // Reset duplicate warning flag when a new video is successfully added
            peers[name].loggedDuplicate = false;
        }

        function toggleMute() {
            localStream.getAudioTracks().forEach(track => track.enabled = !track.enabled);
            isMuted = !isMuted;
            document.getElementById('mute-btn').textContent = isMuted ? 'Unmute' : 'Mute';
        }

        function toggleVideo() {
            localStream.getVideoTracks().forEach(track => track.enabled = !track.enabled);
            isVideoStopped = !isVideoStopped;
            document.getElementById('video-btn').textContent = isVideoStopped ? 'Start Video' : 'Stop Video';
        }

        function handleUserDisconnect(name) {
            console.log(`ðŸšª User ${name} disconnected`);

            // Remove video element if it exists
            const videoElement = document.getElementById(`video-${name}`);
            if (videoElement) {
                videoElement.remove();
                console.log(`ðŸ—‘ Removed video for ${name}`);
            }

            // Close and delete the peer connection
            if (peers[name]) {
                peers[name].close();
                delete peers[name];
                console.log(`ðŸ”Œ Closed peer connection for ${name}`);
            }
        }

    </script>
</body>
</html>
